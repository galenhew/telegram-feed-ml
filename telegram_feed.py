# -*- coding: utf-8 -*-
"""
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13Wc67DLCIoPz2zuM-nNp4xMnHxXe_L3p

References 
- https://www.kaggle.com/product-feedback/181022 
- https://github.com/OMIII1997/Telegram-Bot-for-Model-Training-Updates

guide
- create bot in botfather on telegram
- get api key and use it here
"""


import requests
import tensorflow as tf
import matplotlib.pyplot as plt
import time


notebook_name= 'telegram-colab notebook'

import yaml

with open("config.yaml", "r") as yamlfile:
    data = yaml.load(yamlfile, Loader=yaml.FullLoader)
    access_token= data['telegram_api']['access_token']



class botCallback(tf.keras.callbacks.Callback):
    def __init__(self,access_token, notebook_name):
        self.access_token = access_token

        if notebook_name is None:
            self.notebook_name = 'noteboook name not provided'
        else:
          self.notebook_name = notebook_name

        self.ping_url = 'https://api.telegram.org/bot'+str(self.access_token)+'/getUpdates'
        self.response = requests.get(self.ping_url).json()
        #print(self.response)
        self.chat_id = self.response['result'][0]['message']['chat']['id']
        # self.chat_id = '960266211'
        #self.chat_id = self.response['result']


    def send_message(self,message):
        #print('sending message')
        self.ping_url = 'https://api.telegram.org/bot'+str(self.access_token)+'/sendMessage?'+\
                        'chat_id='+str(self.chat_id)+\
                        '&parse_mode=Markdown'+\
                        '&text='+message
        self.response = requests.get(self.ping_url)
    
    def send_photo(self,filepath):
        imagefile= open(filepath,"rb")
        file_dict = {'photo':imagefile}
        self.ping_url = 'https://api.telegram.org/bot'+str(self.access_token)+'/sendPhoto?chat_id='+str(self.chat_id)
        self.response = requests.post(self.ping_url, files = file_dict)
        imagefile.close()


    def on_train_begin(self, logs= None):
      message = '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TRAINING FOR <'+ self.notebook_name.upper() + '> STARTED ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      try:
        self.send_message(message)
      except:
        pass         


    def on_train_end(self, logs= None):
      message = '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TRAINING FOR <'+ self.notebook_name.upper() + '> ENDED ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
      try:
        self.send_message(message)
      except:
        pass    


    def on_train_batch_begin(self, batch, logs=None):
        pass
        ## test whether it works 
        # print('Training: batch {} begins at {}'.format(batch, datetime.datetime.now().time()))
        # self.send_message('make it work dicky')
    
    def on_train_batch_end(self, batch, logs=None):
        message = ' Iteration/Batch {}\n Training Accuracy : {:7.2f}\n Training Loss : {:7.2f}\n'.format(batch,logs['accuracy'],logs['loss'])
        #print(logs)
        try:
            message += ' Validation Accuracy : {:7.2f}\n Validation Loss : {:7.2f}\n'.format(logs['val_accuracy'],logs['val_loss'])
            self.send_message(message)
        except:
            pass

    def on_test_batch_begin(self, batch, logs=None):
        pass
    
    def on_test_batch_end(self, batch, logs=None):
        message = ' Iteration/Batch {}\n Training Accuracy : {:7.2f}\n Training Loss : {:7.2f}\n'.format(batch,logs['accuracy'],logs['loss'])
        try:
            message += ' Validation Accuracy : {:7.2f}\n Validation Loss : {:7.2f}\n'.format(logs['val_accuracy'],logs['val_loss'])
            self.send_message(message)
        except:
            pass

    def on_epoch_begin(self, epoch, logs=None):
        pass
        # ratio = logs["val_loss"] / logs["loss"]
        # print("Epoch: {}, Val/Train loss ratio: {:.2f}".format(epoch, ratio))
        # print(logs)
        # self.send_message('come onnn')

    def on_epoch_end(self, epoch, logs=None):

        message = ' Epoch {}\n Training Accuracy : {:7.2f}\n Training Loss : {:7.2f}\n'.format(epoch,logs['accuracy'],logs['loss'])
        try:
            message += ' Validation Accuracy : {:7.2f}\n Validation Loss : {:7.2f}\n'.format(logs['val_accuracy'],logs['val_loss'])
            self.send_message(message)        
        except:
            pass

class Plotter(botCallback):
 def __init__(self,access_token, notebook_name):   
     super().__init__(access_token, notebook_name)
 
 def on_train_begin(self,logs=None):
     self.batch = 0
     self.epoch = []
     self.train_loss = []
     self.val_loss = []
     self.train_acc = []
     self.val_acc = []
     self.fig = plt.figure(figsize=(200,100))
     self.logs = []

 def on_epoch_end(self, epoch, logs=None):
     self.logs.append(logs)
     self.epoch.append(epoch)
     self.train_loss.append(logs['loss'])
     self.val_loss.append(logs['val_loss'])
     self.train_acc.append(logs['accuracy'])
     self.val_acc.append(logs['val_accuracy'])
     f,(ax1,ax2) = plt.subplots(1,2,sharex=True)
     #clear_output(wait=True)
     ax1.plot(self.epoch, self.train_loss, label='Training Loss')
     ax1.plot(self.epoch, self.val_loss, label='Validation Loss')
     ax1.legend()
     ax2.plot(self.epoch, self.train_acc, label='Training Accuracy')
     ax2.plot(self.epoch, self.val_acc, label='Validation Accuracy')
     ax2.legend()
     plt.savefig('Accuracy and Loss plot.jpg')
     self.send_photo('Accuracy and Loss plot.jpg')


if __name__ == '__main__':
    mnist = tf.keras.datasets.mnist

    (x_train, y_train), (x_test, y_test) = mnist.load_data()
    x_train, x_test = x_train.reshape(60000, 784).astype('float32') / 255.0, x_test.reshape(10000, 784).astype('float32') / 255.0

    val_data= (x_test, y_test)

    model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(28, 28)),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10)
    ])

    predictions = model(x_train[:1]).numpy()
    predictions

    tf.nn.softmax(predictions).numpy()

    loss_fn = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)
    loss_fn(y_train[:1], predictions).numpy()

    model.compile(optimizer='adam',
                loss=loss_fn,
                metrics=['accuracy'])

    # validation_data required for val_loss metrics etc else error

    bot_callback = botCallback(access_token, notebook_name)
    plotter = Plotter(access_token, notebook_name)
    callback_list = [bot_callback,
                    plotter
                    ]
    start = time.time()

    history = model.fit(x_train, y_train, 
                        steps_per_epoch = 5,
                        epochs=5,
                        validation_data= val_data,
                        callbacks=callback_list)
    end = time.time()
    time_taken= "Total train time: " + str((end-start)/60) + " mins"

    print("Total train time: ",time_taken," mins")
    bot_callback.send_message(time_taken)